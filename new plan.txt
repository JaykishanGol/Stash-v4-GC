Based on my analysis of the Stash-v4-GC repository, here are the answers to all your questions:

## ‚úÖ ANSWERS FROM REPOSITORY ANALYSIS

### 1. **Database Structure**

**Current Tables:**
- **`items`** - Main table for notes/folders/items (type field: 'note', 'folder')
  - Has: `id`, `user_id`, `type`, `title`, `content` (JSONB), `folder_id`, `tags[]`, `is_pinned`, `is_completed`, `priority`, `due_at`, `bg_color`, `remind_at`, `reminder_recurring`, `deleted_at`, `created_at`, `updated_at`
- **`tasks`** - Task management with item relationships
  - Has: `id`, `user_id`, `list_id`, `title`, `description`, `color`, `priority`, `item_ids[]`, `item_completion` (JSONB), `is_completed`, `due_at`, `remind_at`, `reminder_recurring`, `deleted_at`, `created_at`, `updated_at`
- **`lists`** - Custom lists/collections
  - Has: `id`, `user_id`, `name`, `color`, `order`, `items[]`
- **`google_resource_links`** - Google sync mapping
  - Maps local items/tasks to Google Calendar events and Google Tasks
  - Has: `local_id`, `local_type`, `google_id`, `resource_type`, `etag`, `calendar_id`, `task_list_id`, `last_synced_at`

**JSONB Usage:**
- ‚úÖ `items.content` - TipTap JSON content (rich text)
- ‚úÖ `tasks.item_completion` - Map of item completion status `{"itemId": true/false}`

**Soft Delete:**
- ‚úÖ Using `deleted_at` timestamp (NULL = active, timestamp = deleted)
- No separate trash table

**Attachments:**
- ‚úÖ Supabase Storage bucket: `stash_vault`
- Storage path: `{user_id}/{item_id}/...`
- RLS policies for user isolation implemented

### 2. **Content Operations**

**Currently Missing Cut/Copy/Paste:**
- ‚ùå No clipboard store in codebase
- ‚ùå No cut/copy/paste operations implemented
- **Needs:** Both item-level (entire notes/tasks) AND content-level (TipTap rich text)
- **Should Support:** Cross-device clipboard via Supabase (store in DB temporarily)
- **Rich Text:** Copy with formatting (TipTap JSON format)

### 3. **Item Management**

**Current Features:**
- ‚úÖ Move between folders (via `folder_id` update)
- ‚ùå No duplicate function found
- ‚ùå No merge function
- ‚ùå No split function
- ‚ùå No batch operations UI (but DB supports it)

**Needed:**
- Batch selection UI
- Multi-select with checkboxes
- Bulk actions toolbar

### 4. **Storage Strategy**

**Current Implementation:**
- ‚úÖ Supabase Storage (`stash_vault` bucket)
- ‚úÖ User isolation via RLS
- **File Types:** Not specified (likely images primarily)
- **Size Limit:** Not defined in code
- ‚ùå No image compression before upload
- ‚ùå No version history for notes

**Needs:**
- Image compression (browser-image-compression library)
- File type validation
- Size limits
- Thumbnail generation
- Version history table

### 5. **Undo/Redo Logic**

**Current:**
- ‚úÖ TipTap has built-in content-level undo/redo
- ‚ùå No app-level undo/redo for deletes, moves, etc.

**Needs:**
- History stack in Zustand
- Undo for: delete, move, archive operations
- 20-50 levels of history

### 6. **Sync & Conflict Resolution**

**Current Strategy:**
- ‚úÖ Soft delete with `deleted_at` timestamp
- ‚úÖ `updated_at` triggers for sync detection
- ‚úÖ Google sync via `google_resource_links` table
- ‚ùå No explicit conflict resolution logic found
- **Appears to use:** Last Write Wins (based on `updated_at`)

**Needs:**
- Optimistic updates with TanStack Query (likely implemented but need to verify)
- Conflict detection UI
- Manual conflict resolution option
- Offline queue for failed operations

### 7. **Data Relationships**

**Current Relationships:**
- ‚úÖ Items can be inside folders (`folder_id`)
- ‚úÖ Tasks have array of item IDs (`item_ids[]`)
- ‚úÖ Tasks can contain multiple items (checklist style)
- ‚úÖ Lists contain items (`items[]` array)
- ‚ùå No bidirectional note-to-note links
- ‚ùå No backlinks

**Structure:**
```
items (notes/folders)
  ‚îî‚îÄ folder_id ‚Üí parent item
  
tasks
  ‚îú‚îÄ list_id ‚Üí list
  ‚îî‚îÄ item_ids[] ‚Üí items (many-to-many via array)
  
lists
  ‚îî‚îÄ items[] ‚Üí item IDs
```

### 8. **Google Integration**

**Current Implementation:**
- ‚úÖ `google_resource_links` table maps local ‚Üî Google
- ‚úÖ Tracks `etag` for version control
- ‚úÖ Stores `calendar_id` and `task_list_id`
- ‚ùå Delete sync logic not visible in schema

**Needs:**
- Two-way delete sync handling
- Conflict resolution when deleted on one side
- Orphaned link cleanup

### 9. **Performance Concerns**

**Current Optimizations:**
- ‚úÖ Trigram extension (`pg_trgm`) for fuzzy search
- ‚úÖ GIN indexes on title and content
- ‚úÖ Search RPC function (server-side)
- ‚úÖ Recursive folder delete function (prevents client-side loops)
- ‚úÖ `handle_item_deletion()` trigger for referential integrity

**Expected Scale:**
- Target: 1,000-10,000 items per user
- **Needs:** Pagination or infinite scroll (not yet implemented)
- **Needs:** Virtual scrolling (react-window installed but need to check usage)

### 10. **Special Requirements**

**Currently Missing:**
- ‚ùå Templates system
- ‚ùå Import from other apps
- ‚ùå Export in multiple formats
- ‚ùå Drag-and-drop implementation
- ‚ùå Keyboard shortcuts
- ‚ùå Mobile gestures (swipe to delete)

***

## üìã REFINED PROMPT WITH ACTUAL CONTEXT

Now I'll create the ultimate prompt with this context:

```markdown
# Comprehensive Database, Storage & Item Operations Implementation for Stash-v4-GC

## Project Context

**Repository:** https://github.com/JaykishanGol/Stash-v4-GC
**Stack:** React 19.2 + TypeScript + Supabase + Zustand + TanStack Query + TipTap + Wouter

## Current State Analysis

### Existing Database Schema

**Tables Implemented:**
1. **`items`** table - Notes and folders with:
   - Rich text content (JSONB TipTap format)
   - Hierarchical folders (`folder_id`)
   - Tags array, pinning, completion
   - Priority and due dates
   - Soft delete (`deleted_at`)
   - Colors and metadata

2. **`tasks`** table - Task management with:
   - Relationships to items via `item_ids[]` array
   - Item completion tracking (JSONB map)
   - List membership (`list_id`)
   - Priority, due dates, reminders
   - Recurring reminders

3. **`lists`** table - Custom collections:
   - Item references (`items[]` array)
   - Color and ordering

4. **`google_resource_links`** - Google sync:
   - Maps local items/tasks to Google Calendar/Tasks
   - Stores ETags for versioning
   - Tracks last sync time

**Storage:**
- Supabase Storage bucket: `stash_vault`
- Path structure: `{user_id}/{item_id}/filename`
- RLS policies for user isolation

**Performance Features:**
- PostgreSQL trigram extension for fuzzy search
- GIN indexes on title and content
- Server-side recursive folder deletion
- Automatic referential integrity (triggers)
- Search RPC function with ranking

### What's Missing

**CRITICAL GAPS:**
1. ‚ùå No clipboard system (cut/copy/paste)
2. ‚ùå No batch operations UI
3. ‚ùå No duplicate/merge/split functions
4. ‚ùå No image compression before upload
5. ‚ùå No version history
6. ‚ùå No app-level undo/redo
7. ‚ùå No conflict resolution UI
8. ‚ùå No drag-and-drop
9. ‚ùå No keyboard shortcuts
10. ‚ùå No export/import functions
11. ‚ùå No templates system
12. ‚ùå No pagination implementation

---

## PART 1: COMPLETE CLIPBOARD SYSTEM

### 1.1 Three-Level Clipboard Architecture

Design a comprehensive clipboard system with:

**Level 1: Native Browser Clipboard (Text Only)**
```typescript
// Basic text copy/paste using Clipboard API
async function copyTextToClipboard(text: string): Promise<void>
async function pasteTextFromClipboard(): Promise<string>
```

**Level 2: TipTap Rich Text Clipboard**
```typescript
// Within editor - preserve formatting
// Use TipTap's built-in clipboard with custom extensions
// Support: Bold, Italic, Lists, Links, Code blocks, Tables

const ClipboardExtension = Extension.create({
  name: 'customClipboard',
  // Handle rich content copy/paste
  // Preserve TipTap JSON structure
})
```

**Level 3: App-Level Item Clipboard (Cross-Device)**
```typescript
// Store in Zustand + Supabase for cross-device support

interface ClipboardStore {
  action: 'copy' | 'cut' | null;
  itemType: 'note' | 'task' | 'folder' | 'list' | null;
  itemIds: string[];
  data: any[];
  timestamp: number;
}

// Sync clipboard to Supabase (ephemeral table, 24hr TTL)
CREATE TABLE clipboard_cache (
  user_id UUID PRIMARY KEY,
  action TEXT,
  item_type TEXT,
  item_data JSONB,
  expires_at TIMESTAMPTZ DEFAULT (NOW() + INTERVAL '24 hours')
);
```

### 1.2 Copy Implementation

**Requirements:**
- Copy single or multiple items (notes, tasks, folders, lists)
- Copy with all relationships (tasks ‚Üí items, lists ‚Üí items)
- Copy with attachments (duplicate files in storage)
- Visual feedback (toast notification)
- Keyboard shortcut: Cmd/Ctrl+C

**Implementation:**
```typescript
// Provide complete implementation for:

1. copyNote(noteId: string): Promise<void>
2. copyMultipleNotes(noteIds: string[]): Promise<void>
3. copyTask(taskId: string): Promise<void>
4. copyFolder(folderId: string, includeChildren: boolean): Promise<void>
5. copyWithAttachments(itemId: string): Promise<void>
6. syncClipboardToDatabase(): Promise<void>
```

### 1.3 Cut Implementation

**Requirements:**
- Mark items as "cut" (visual dimming in UI)
- Don't delete until paste
- Same types as copy
- Keyboard shortcut: Cmd/Ctrl+X

### 1.4 Paste Implementation

**Requirements:**
- **Copy-Paste:** Duplicate items with new IDs
  - Append " (Copy)" to title
  - Duplicate attachments in storage
  - Maintain relationships (if copying folder, copy all children)
  
- **Cut-Paste:** Move items
  - Update `folder_id` or `list_id`
  - No duplication
  
- Handle paste into:
  - Folders (change `folder_id`)
  - Lists (add to `items[]` array)
  - Root level (`folder_id` = NULL)

- Keyboard shortcut: Cmd/Ctrl+V

```typescript
// Provide implementation for:

async function pasteItems(
  targetType: 'folder' | 'list' | 'root',
  targetId: string | null
): Promise<void>

async function handleCopyPaste(...): Promise<void>
async function handleCutPaste(...): Promise<void>
async function duplicateAttachments(sourceItemId: string, targetItemId: string): Promise<void>
```

---

## PART 2: BATCH OPERATIONS SYSTEM

### 2.1 Selection Store

```typescript
// Zustand store for multi-select

interface SelectionStore {
  selectedIds: Set<string>;
  selectMode: boolean;
  lastSelectedId: string | null; // For shift-click range selection
}

export const useSelectionStore = create<SelectionStore>((set) => ({
  // Provide complete implementation with:
  toggleSelect(id: string): void
  selectAll(ids: string[]): void
  selectRange(startId: string, endId: string, allIds: string[]): void
  clearSelection(): void
  enterSelectMode(): void
  exitSelectMode(): void
}));
```

### 2.2 Batch Operations

**Implement:**
- Copy multiple
- Cut multiple
- Move to folder (multiple)
- Move to list (multiple)
- Delete multiple (move to trash)
- Archive multiple
- Tag multiple (add/remove tags)
- Change color (multiple)
- Change priority (multiple)
- Pin/unpin (multiple)

```typescript
// Provide complete implementations:

async function batchMoveToFolder(itemIds: string[], folderId: string): Promise<void>
async function batchMoveToTrash(itemIds: string[]): Promise<void>
async function batchRestore(itemIds: string[]): Promise<void>
async function batchPermanentDelete(itemIds: string[]): Promise<void>
async function batchAddTags(itemIds: string[], tags: string[]): Promise<void>
async function batchRemoveTags(itemIds: string[], tags: string[]): Promise<void>
async function batchUpdatePriority(itemIds: string[], priority: string): Promise<void>
```

### 2.3 Batch Operations UI

```tsx
// Provide complete React component:

function BatchOperationsBar() {
  // Show when items are selected
  // Actions: Copy, Cut, Move, Delete, Archive, Tag, Color, Priority
  // Show count of selected items
  // Cancel button to exit select mode
}

// Checkbox component for items
function SelectableItem({ item, children }) {
  // Long-press on mobile to enter select mode
  // Checkbox visible in select mode
  // Click to toggle selection
}
```

---

## PART 3: ADVANCED ITEM OPERATIONS

### 3.1 Duplicate Function

```typescript
// Single item duplication
async function duplicateNote(noteId: string): Promise<string>
async function duplicateTask(taskId: string): Promise<string>
async function duplicateFolder(folderId: string, duplicateChildren: boolean): Promise<string>

// Requirements:
- Append " (Copy)" to title
- Generate new IDs
- Duplicate attachments in storage
- Maintain internal structure (folder ‚Üí children)
- Return new item ID
```

### 3.2 Merge Notes

```typescript
async function mergeNotes(noteIds: string[], strategy: 'concatenate' | 'sections'): Promise<string>

// Strategy 'concatenate': Join content with separator
// Strategy 'sections': Create headings for each note
// Move original notes to trash (with undo)
// Combine tags (unique)
// Use earliest created_at
// Return merged note ID
```

### 3.3 Split Note

```typescript
async function splitNote(
  noteId: string,
  splitStrategy: 'headers' | 'manual',
  splitPoints?: number[] // For manual: character positions or block indices
): Promise<string[]>

// Strategy 'headers': Split by H1/H2 tags in TipTap content
// Strategy 'manual': Split at specified positions
// Create new notes for each section
// Move original to trash (with undo)
// Return array of new note IDs
```

### 3.4 Move Operations

```typescript
// Already have folder_id update, but enhance:

async function moveToFolder(itemIds: string[], targetFolderId: string | null): Promise<void>
async function moveToList(itemIds: string[], listId: string): Promise<void>
async function moveToTrash(itemIds: string[]): Promise<void>
async function restoreFromTrash(itemIds: string[]): Promise<void>
async function permanentDelete(itemIds: string[]): Promise<void>

// Add history tracking for undo
```

---

## PART 4: DRAG AND DROP SYSTEM

### 4.1 HTML5 Drag and Drop

```typescript
// Provide complete implementation:

// Draggable item component
function DraggableItem({ item, children }) {
  const handleDragStart = (e: React.DragEvent) => {
    // Set data transfer
    // Visual feedback (ghost image)
  };
  
  return (
    <div draggable onDragStart={handleDragStart} onDragEnd={handleDragEnd}>
      {children}
    </div>
  );
}

// Drop target (folder)
function DroppableFolder({ folder, children }) {
  const handleDragOver = (e: React.DragEvent) => {
    // Allow drop
    // Visual indicator
  };
  
  const handleDrop = async (e: React.DragEvent) => {
    // Parse dragged item
    // Move to folder
  };
  
  return (
    <div onDragOver={handleDragOver} onDrop={handleDrop} onDragLeave={handleDragLeave}>
      {children}
    </div>
  );
}

// Support:
- Drag notes into folders
- Drag tasks into lists
- Drag to reorder (within same container)
- Multi-drag (if items selected)
- Mobile: Long-press to drag
```

### 4.2 Mobile Drag (Alternative)

```typescript
// For better mobile experience, use touch events

function useLongPressDrag(item: Item) {
  // Long-press initiates drag mode
  // Follow finger
  // Drop on release
}
```

---

## PART 5: UNDO/REDO SYSTEM

### 5.1 History Store

```typescript
interface HistoryEntry {
  type: 'create' | 'update' | 'delete' | 'move' | 'batch';
  timestamp: number;
  itemType: 'note' | 'task' | 'folder' | 'list';
  itemIds: string[];
  previousState: any; // Snapshot of data before action
  action: string; // Description for UI
  undo: () => Promise<void>; // Function to undo
  redo: () => Promise<void>; // Function to redo
}

export const useHistoryStore = create<{
  undoStack: HistoryEntry[];
  redoStack: HistoryEntry[];
}>((set, get) => ({
  undoStack: [],
  redoStack: [],
  
  pushHistory(entry: HistoryEntry): void,
  undo(): Promise<void>,
  redo(): Promise<void>,
  canUndo(): boolean,
  canRedo(): boolean,
}));
```

### 5.2 Undoable Operations

**Track history for:**
- Delete items (restore from trash)
- Move items (restore previous folder)
- Batch operations
- Tag changes
- Priority changes
- Merge notes (restore originals)
- Split notes (restore original)

**NOT tracked (handled by TipTap):**
- Content edits within notes

### 5.3 Keyboard Shortcuts

```typescript
// Cmd/Ctrl+Z: Undo
// Cmd/Ctrl+Shift+Z: Redo

useEffect(() => {
  const handleKeyDown = (e: KeyboardEvent) => {
    const isMod = e.metaKey || e.ctrlKey;
    
    if (isMod && e.key === 'z') {
      e.preventDefault();
      if (e.shiftKey) {
        historyStore.redo();
      } else {
        historyStore.undo();
      }
    }
  };
  
  window.addEventListener('keydown', handleKeyDown);
  return () => window.removeEventListener('keydown', handleKeyDown);
}, []);
```

---

## PART 6: STORAGE ENHANCEMENTS

### 6.1 Image Compression

```typescript
import imageCompression from 'browser-image-compression';

async function compressAndUpload(file: File, itemId: string): Promise<string> {
  // Compress image if > 1MB
  const options = {
    maxSizeMB: 1,
    maxWidthOrHeight: 1920,
    useWebWorker: true,
    fileType: 'image/webp', // Convert to WebP for better compression
  };
  
  const compressedFile = await imageCompression(file, options);
  
  // Upload to Supabase Storage
  const path = `${userId}/${itemId}/${Date.now()}_${file.name}`;
  const { data, error } = await supabase.storage
    .from('stash_vault')
    .upload(path, compressedFile);
  
  return data.path;
}
```

### 6.2 Thumbnail Generation

```typescript
async function generateThumbnail(file: File): Promise<Blob> {
  // Create thumbnail (200x200)
  const options = {
    maxSizeMB: 0.1,
    maxWidthOrHeight: 200,
    useWebWorker: true,
  };
  
  return await imageCompression(file, options);
}
```

### 6.3 File Management

```typescript
// Attachment metadata table

CREATE TABLE attachments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  item_id UUID NOT NULL REFERENCES items(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  filename TEXT NOT NULL,
  original_filename TEXT NOT NULL,
  file_type TEXT NOT NULL,
  file_size INTEGER NOT NULL,
  
  storage_path TEXT NOT NULL,
  thumbnail_path TEXT,
  
  width INTEGER,
  height INTEGER,
  
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- RLS policies
-- Indexes on item_id and user_id

// TypeScript interface
interface Attachment {
  id: string;
  item_id: string;
  filename: string;
  original_filename: string;
  file_type: string;
  file_size: number;
  storage_path: string;
  thumbnail_path: string | null;
  width: number | null;
  height: number | null;
  created_at: string;
}

// CRUD functions
async function uploadAttachment(itemId: string, file: File): Promise<Attachment>
async function deleteAttachment(attachmentId: string): Promise<void>
async function getAttachments(itemId: string): Promise<Attachment[]>
async function duplicateAttachment(attachmentId: string, newItemId: string): Promise<Attachment>
```

---

## PART 7: VERSION HISTORY

### 7.1 Version History Table

```sql
CREATE TABLE item_versions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  item_id UUID NOT NULL REFERENCES items(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  
  version INTEGER NOT NULL,
  title TEXT NOT NULL,
  content JSONB NOT NULL,
  
  -- Diff from previous version (optional, for efficiency)
  content_diff JSONB,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES auth.users(id)
);

-- Indexes
CREATE INDEX idx_item_versions_item ON item_versions(item_id, version DESC);

-- RLS
-- Keep last 50 versions per item (cleanup old versions)
```

### 7.2 Version Tracking

```typescript
// Automatic versioning trigger
CREATE OR REPLACE FUNCTION create_item_version()
RETURNS TRIGGER AS $$
BEGIN
  -- Only create version if content changed
  IF (OLD.content IS DISTINCT FROM NEW.content) OR (OLD.title IS DISTINCT FROM NEW.title) THEN
    INSERT INTO item_versions (item_id, user_id, version, title, content)
    SELECT 
      NEW.id,
      NEW.user_id,
      COALESCE(MAX(version), 0) + 1,
      NEW.title,
      NEW.content
    FROM item_versions
    WHERE item_id = NEW.id;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_item_update_version
  AFTER UPDATE ON items
  FOR EACH ROW
  EXECUTE FUNCTION create_item_version();
```

### 7.3 Version UI

```typescript
// Fetch versions
async function getVersionHistory(itemId: string): Promise<ItemVersion[]>

// Restore version
async function restoreVersion(itemId: string, versionId: string): Promise<void>

// Compare versions
async function compareVersions(versionId1: string, versionId2: string): Promise<Diff>

// UI Component
function VersionHistoryModal({ itemId }) {
  // Timeline of versions
  // Preview version
  // Restore button
  // Compare mode
}
```

---

## PART 8: IMPORT/EXPORT SYSTEM

### 8.1 Export Functions

```typescript
// Export as JSON (all data, includes relationships)
async function exportAsJSON(itemIds: string[]): Promise<void>

// Export as Markdown (concatenated notes)
async function exportAsMarkdown(itemIds: string[]): Promise<void>

// Export as HTML (rich text preserved)
async function exportAsHTML(itemIds: string[]): Promise<void>

// Export as PDF (using html2pdf or similar)
async function exportAsPDF(itemIds: string[]): Promise<void>

// Export attachments (zip file with notes + files)
async function exportWithAttachments(itemIds: string[]): Promise<void>

// Bulk export (entire workspace)
async function exportWorkspace(): Promise<void>
```

### 8.2 Import Functions

```typescript
// Import from JSON (restore from export)
async function importFromJSON(file: File): Promise<ImportResult>

// Import from Markdown
async function importFromMarkdown(file: File): Promise<ImportResult>

// Import from Notion (via API or export file)
async function importFromNotion(file: File): Promise<ImportResult>

// Import from Evernote (ENEX format)
async function importFromEvernote(file: File): Promise<ImportResult>

// Import from Google Keep (via API)
async function importFromGoogleKeep(): Promise<ImportResult>

interface ImportResult {
  success: number;
  failed: number;
  errors: string[];
  importedIds: string[];
}
```

---

## PART 9: KEYBOARD SHORTCUTS

### 9.1 Global Shortcuts

```typescript
const shortcuts = {
  // Navigation
  'Cmd/Ctrl+K': 'Quick search / command palette',
  'Cmd/Ctrl+B': 'Toggle sidebar',
  'Cmd/Ctrl+\\': 'Toggle folder tree',
  
  // Item operations
  'Cmd/Ctrl+N': 'New note',
  'Cmd/Ctrl+Shift+N': 'New folder',
  'Cmd/Ctrl+T': 'New task',
  
  // Clipboard
  'Cmd/Ctrl+C': 'Copy',
  'Cmd/Ctrl+X': 'Cut',
  'Cmd/Ctrl+V': 'Paste',
  'Cmd/Ctrl+D': 'Duplicate',
  
  // Undo/Redo
  'Cmd/Ctrl+Z': 'Undo',
  'Cmd/Ctrl+Shift+Z': 'Redo',
  
  // Selection
  'Cmd/Ctrl+A': 'Select all',
  'Escape': 'Clear selection',
  
  // Navigation
  'ArrowUp/Down': 'Navigate items',
  'Enter': 'Open selected item',
  'Delete/Backspace': 'Move to trash',
  'Cmd/Ctrl+Delete': 'Permanent delete',
  
  // Editing
  'Cmd/Ctrl+E': 'Edit mode',
  'Cmd/Ctrl+S': 'Save (redundant, auto-save)',
  
  // View
  'Cmd/Ctrl+1/2/3': 'Switch views (grid/list/masonry)',
  'Cmd/Ctrl+F': 'Search in current view',
  
  // Tags & filters
  'Cmd/Ctrl+Shift+T': 'Add tag',
  'Cmd/Ctrl+Shift+F': 'Toggle filter',
  
  // Quick actions
  'Cmd/Ctrl+P': 'Pin/unpin',
  'Cmd/Ctrl+Shift+A': 'Archive',
};

// Implementation with mousetrap or custom hook
import { useEffect } from 'react';

export function useKeyboardShortcuts() {
  useEffect(() => {
    // Register all shortcuts
    // Handle conflicts (editor vs app-level)
  }, []);
}
```

---

## PART 10: MOBILE GESTURES

### 10.1 Swipe Gestures

```typescript
// Using react-swipeable or custom touch events

function SwipeableItem({ item, children }) {
  const [offset, setOffset] = useState(0);
  
  const handleSwipeLeft = () => {
    // Show archive/delete button
  };
  
  const handleSwipeRight = () => {
    // Show pin/star button
  };
  
  return (
    <div
      onTouchStart={handleTouchStart}
      onTouchMove={handleTouchMove}
      onTouchEnd={handleTouchEnd}
      style={{ transform: `translateX(${offset}px)` }}
    >
      {children}
      <div className="swipe-actions-left">
        <button>Pin</button>
      </div>
      <div className="swipe-actions-right">
        <button>Archive</button>
        <button>Delete</button>
      </div>
    </div>
  );
}
```

### 10.2 Long Press

```typescript
function useLongPress(callback: () => void, ms = 500) {
  const [startLongPress, setStartLongPress] = useState(false);
  
  useEffect(() => {
    let timerId: NodeJS.Timeout;
    
    if (startLongPress) {
      timerId = setTimeout(callback, ms);
    }
    
    return () => {
      clearTimeout(timerId);
    };
  }, [startLongPress, callback, ms]);
  
  return {
    onTouchStart: () => setStartLongPress(true),
    onTouchEnd: () => setStartLongPress(false),
    onTouchMove: () => setStartLongPress(false),
  };
}

// Use for:
- Long-press to enter select mode
- Long-press to show context menu
- Long-press to initiate drag
```

### 10.3 Pull to Refresh

```typescript
function usePullToRefresh(onRefresh: () => Promise<void>) {
  // Detect pull-down gesture at top of scroll
  // Show loading indicator
  // Call onRefresh
  // Hide indicator when complete
}
```

---

## PART 11: SYNC & CONFLICT RESOLUTION

### 11.1 Optimistic Updates

```typescript
// TanStack Query with optimistic updates

export function useUpdateItem() {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: updateItem,
    
    onMutate: async (newItem) => {
      // Cancel outgoing queries
      await queryClient.cancelQueries({ queryKey: ['items'] });
      
      // Snapshot current data
      const previousItems = queryClient.getQueryData(['items']);
      
      // Optimistically update
      queryClient.setQueryData(['items'], (old: Item[]) =>
        old.map(item => item.id === newItem.id ? { ...item, ...newItem } : item)
      );
      
      return { previousItems };
    },
    
    onError: (err, newItem, context) => {
      // Rollback on error
      queryClient.setQueryData(['items'], context.previousItems);
      toast.error('Failed to update. Changes reverted.');
    },
    
    onSettled: () => {
      // Refetch to ensure consistency
      queryClient.invalidateQueries({ queryKey: ['items'] });
    },
  });
}
```

### 11.2 Conflict Detection

```typescript
// Detect conflicts by comparing updated_at timestamps

interface ConflictInfo {
  localItem: Item;
  remoteItem: Item;
  conflictFields: string[]; // Which fields differ
}

async function detectConflicts(): Promise<ConflictInfo[]> {
  // Fetch items from server
  // Compare with local state (Zustand + IndexedDB for offline)
  // Identify conflicts
}
```

### 11.3 Conflict Resolution UI

```typescript
function ConflictResolutionModal({ conflicts }: { conflicts: ConflictInfo[] }) {
  return (
    <Modal>
      <h2>{conflicts.length} Conflicts Detected</h2>
      {conflicts.map(conflict => (
        <ConflictItem key={conflict.localItem.id} conflict={conflict}>
          <button onClick={() => resolveConflict('keep-local')}>
            Keep My Changes
          </button>
          <button onClick={() => resolveConflict('keep-remote')}>
            Use Server Version
          </button>
          <button onClick={() => resolveConflict('merge')}>
            Merge Both
          </button>
        </ConflictItem>
      ))}
    </Modal>
  );
}

// Resolution strategies
async function resolveConflict(
  conflict: ConflictInfo,
  strategy: 'keep-local' | 'keep-remote' | 'merge' | 'manual'
): Promise<void>
```

### 11.4 Offline Queue

```typescript
// Queue failed operations when offline

interface QueuedOperation {
  id: string;
  type: 'create' | 'update' | 'delete';
  itemType: string;
  data: any;
  timestamp: number;
  retries: number;
}

export const useOfflineQueue = create<{
  queue: QueuedOperation[];
}>((set, get) => ({
  queue: [],
  
  addToQueue(operation: QueuedOperation): void,
  processQueue(): Promise<void>,
  clearQueue(): void,
}));

// Auto-process when back online
useEffect(() => {
  const handleOnline = () => {
    offlineQueue.processQueue();
  };
  
  window.addEventListener('online', handleOnline);
  return () => window.removeEventListener('online', handleOnline);
}, []);
```

---

## PART 12: TEMPLATES SYSTEM

### 12.1 Templates Table

```sql
CREATE TABLE templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  
  name TEXT NOT NULL,
  description TEXT,
  category TEXT, -- 'note', 'task', 'folder'
  
  content JSONB NOT NULL, -- Template content (TipTap JSON)
  is_public BOOLEAN DEFAULT FALSE, -- Share with community
  
  usage_count INTEGER DEFAULT 0,
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- System templates (user_id NULL)
INSERT INTO templates (user_id, name, category, content, is_public) VALUES
(NULL, 'Meeting Notes', 'note', '{"type":"doc","content":[...]}', TRUE),
(NULL, 'Daily Journal', 'note', '{"type":"doc","content":[...]}', TRUE),
(NULL, 'Project Plan', 'note', '{"type":"doc","content":[...]}', TRUE);
```

### 12.2 Template Functions

```typescript
// Create note from template
async function createFromTemplate(templateId: string): Promise<string>

// Save as template
async function saveAsTemplate(itemId: string, name: string): Promise<string>

// Browse templates
async function listTemplates(category?: string): Promise<Template[]>

// Delete template
async function deleteTemplate(templateId: string): Promise<void>
```

---

## DELIVERABLES

Please provide complete implementations for:

1. ‚úÖ **Clipboard System** (3 levels)
2. ‚úÖ **Batch Operations** (store + UI + functions)
3. ‚úÖ **Advanced Operations** (duplicate, merge, split)
4. ‚úÖ **Drag and Drop** (desktop + mobile)
5. ‚úÖ **Undo/Redo** (app-level history)
6. ‚úÖ **Storage Enhancements** (compression, thumbnails, attachments table)
7. ‚úÖ **Version History** (table + tracking + UI)
8. ‚úÖ **Import/Export** (multiple formats)
9. ‚úÖ **Keyboard Shortcuts** (comprehensive)
10. ‚úÖ **Mobile Gestures** (swipe, long-press, pull-to-refresh)
11. ‚úÖ **Conflict Resolution** (detection + UI + strategies)
12. ‚úÖ **Templates System** (table + functions)
13. ‚úÖ **Database Optimizations** (additional indexes, functions)
14. ‚úÖ **TypeScript Types** (all new entities)
15. ‚úÖ **TanStack Query Hooks** (all CRUD operations)
16. ‚úÖ **Testing Strategy** (for all operations)
17. ‚úÖ **Migration Plan** (SQL + data migration)

---

## SUCCESS CRITERIA

The implementation should:
- ‚úÖ Work seamlessly offline and online
- ‚úÖ Handle conflicts gracefully
- ‚úÖ Maintain referential integrity
- ‚úÖ Perform well with 10,000+ items
- ‚úÖ Support mobile gestures and touch
- ‚úÖ Provide rich keyboard navigation
- ‚úÖ Enable power-user workflows (batch, templates, shortcuts)
- ‚úÖ Integrate with existing Google sync
- ‚úÖ Match or exceed Notion/Evernote UX

Please begin your comprehensive implementation now, prioritizing the most critical gaps first.
```

This prompt is now **perfectly tailored** to your actual codebase with all the context from the repository analysis!